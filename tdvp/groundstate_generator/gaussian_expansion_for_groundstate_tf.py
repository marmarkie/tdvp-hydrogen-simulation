"""
    This code expands the ground state of a hydrogen atom under the 3D soft Coulomb potential into a 3D-PTG basis. Specifically,

        ψ_groundstate(r) = Σ gi , (0 <= i < n_gaussians)

    where

        gi(x, y, z) = z^ni * e^(γi − αi(x^2 + y^2) − βi z^2)

    The parameters ni are set to 0, and σi = αi = βi due to the spherical symmetry of the ground state.
    γi and σi are obtained using optimizer in tensorflow.

    The ground state is loaded from `soft_coulomb_potential_radial_solution.npz` generated by `groundstate_solver.py`.
    The results are stored in `groundstate_expansion_params_tf.npz` with keys 'values_γ' and 'values_σ'.
"""

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras import layers, models, initializers
import os

# Custom Gaussian activation layer e^(-b^2 * r^2), where b is a trainable parameter
class GaussianLayer(layers.Layer):
    def __init__(self, n_gaussians, **kwargs):
        super(GaussianLayer, self).__init__(**kwargs)
        self.n_gaussians = n_gaussians

    def build(self, input_shape):
        # Initialize trainable parameters a and b
        self.a = self.add_weight(shape=(self.n_gaussians,), initializer=initializers.RandomNormal(), trainable=True, name='a')
        self.b = self.add_weight(shape=(self.n_gaussians,), initializer=initializers.RandomNormal(), trainable=True, name='b')

    def call(self, inputs):
        r = inputs
        r_squared = tf.square(r)
        gaussians = self.a ** 2 * tf.exp(-self.b ** 2 * r_squared)
        return tf.reduce_sum(gaussians, axis=-1, keepdims=True)

# Build the neural network model
def build_model(n_gaussians):
    model = models.Sequential([
        layers.Input(shape=(1,)),
        GaussianLayer(n_gaussians=n_gaussians)
    ])
    return model

# Load data from file
def load_data(filepath):
    data = np.load(filepath)
    return data['r'], data['y']

# Train the model
def train_model(model, r, y, epochs=100, batch_size=32):
    model.compile(optimizer='adam', loss='mse')
    history = model.fit(r, y, epochs=epochs, batch_size=batch_size, verbose=0)
    return history

# Extract the trained Gaussian parameters
def extract_gaussian_params(gaussian_layer, n_gaussians):
    a_values = gaussian_layer.get_weights()[0]
    b_values = gaussian_layer.get_weights()[1]

    gaussian_params = {}
    for i in range(n_gaussians):
        gaussian_params[f'Gaussian {i+1}'] = {'γ': np.complex128(np.log(a_values[i] ** 2)), 'σ': np.complex128(b_values[i] ** 2)}
        print(gaussian_params[f'Gaussian {i+1}'])

    return gaussian_params

# Save the parameters to a .npz file
def save_params_to_npz(filepath, gaussian_params):
    keys = list(gaussian_params.keys())
    values_γ = np.array([gaussian_params[key]['γ'] for key in keys], dtype=np.complex128)
    values_σ = np.array([gaussian_params[key]['σ'] for key in keys], dtype=np.complex128)
    np.savez(filepath, keys=keys, values_γ=values_γ, values_σ=values_σ)

# Plot the results
def plot_results(r, y, y_pred, history, n_gaussians):
    # Compare model prediction with actual data
    plt.figure(figsize=(10, 6))
    plt.plot(r, y, label='ψ_groundstate(r)', color='blue', lw=2)
    plt.plot(r, y_pred, label=f'TensorFlow Gaussian Model (n={n_gaussians})', color='red', linestyle='--', lw=2)
    plt.xlabel('r')
    plt.ylabel('Function value')
    plt.title('Comparison between ψ_groundstate(r) and TensorFlow Gaussian Model Prediction')
    plt.legend()
    plt.grid(True)
    plt.show()

    # Plot the loss function over epochs
    plt.figure(figsize=(10, 6))
    plt.plot(history.history['loss'], label='Training Loss', color='green', lw=2)
    plt.xlabel('Epochs')
    plt.ylabel('Loss')
    plt.title('Training Loss Over Epochs')
    plt.legend()
    plt.grid(True)
    plt.show()

# Print final loss value
def print_final_loss(history):
    history_dict = history.history
    print(f"Final loss: {history_dict['loss'][-1]}")

def main():
    # Change to your path
    os.chdir('E:\\XUTTAI\\Desktop\\tdvp\\groundstate_generator')

    # Load data
    r, y = load_data('soft_coulomb_potential_radial_solution.npz')

    # Define the number of Gaussians
    n_gaussians = 4

    # Build and train the model
    model = build_model(n_gaussians)
    history = train_model(model, r, y, epochs=100, batch_size=32)

    # Predict results
    y_pred = model.predict(r)

    # Extract and save Gaussian parameters
    gaussian_layer = model.layers[0]
    gaussian_params = extract_gaussian_params(gaussian_layer, n_gaussians)
    save_params_to_npz('groundstate_expansion_params_tf.npz', gaussian_params)

    # Plot results and print final loss
    plot_results(r, y, y_pred, history, n_gaussians)
    print_final_loss(history)

if __name__ == '__main__':
    main()

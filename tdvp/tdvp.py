"""
    Note: The paper suggests updating only α and β using dq/dt = −j * M^−1 * v (equation 13)
          while employing the Crank-Nicolson approach to update γ.
          However, this code does not implement the Crank-Nicolson approach
          and instead updates γ using equation 13 as well.

          Although 'groundstate_expansion_params_tf.npz' contains more Gaussian bases, 
          these bases tend to become linearly dependent, 
          leading to significant errors when inverting the M matrix. 
          As a result, 'groundstate_expansion_params.npz' is used instead. 
    
    This code implements the PTG-basis to simulate a hydrogen atom under a soft Coulomb potential.
    The simulation starts from the ground state, with parameters loaded from 'groundstate_expansion_params.npz', 
    which is generated by 'gaussian_expansion_for_groundstate.py' and contains 5 PTG bases (all with n = 0).
    The parameters of the soft Coulomb potential are loaded from 'V0_expansion_params.npz', 
    which is generated by 'gaussian_expansion_for_potential.py' and contains 5 Gaussian bases.
    The initial energy is -0.27490287, which is close to -0.27489135 as reported in the paper.
    With dt = 0.001, the energy remains stable within the range t_max = 100.
"""

import numpy as np
import matplotlib.pyplot as plt
import os
import sys
from gaussian_integration import * 

# Evaluate wavefunction at (x, y, z)
def eval_psi(g_sets, x=0, y=0, z=0):
    psi = 0 + 0j
    for g in g_sets:
        psi += z ** g.n * np.exp(g.γ - g.α * (x**2 + y**2) - g.β * z**2)
    return psi

# Create matrix M (equation C7)
def make_M(g_sets):
    n_expansion = len(g_sets)
    M_g_1_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    M_g_1_x2y2_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    M_g_1_z2_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    M_g_1_x2y2_2_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    M_g_1_x2y2z2_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    M_g_1_z4_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)

    for i in range(n_expansion):
        for j in range(n_expansion):
            M_g_1_g_2[i][j] = integrate_g_1_g_2(g_sets[i], g_sets[j])
            M_g_1_x2y2_g_2[i][j] = -integrate_g_1_x2y2_g_2(g_sets[i], g_sets[j])
            M_g_1_z2_g_2[i][j] = -integrate_g_1_z2_g_2(g_sets[i], g_sets[j])
            M_g_1_x2y2_2_g_2[i][j] = integrate_g_1_x2y2_2_g_2(g_sets[i], g_sets[j])
            M_g_1_x2y2z2_g_2[i][j] = integrate_g_1_x2y2z2_g_2(g_sets[i], g_sets[j])
            M_g_1_z4_g_2[i][j] = integrate_g_1_z4_g_2(g_sets[i], g_sets[j])

    M_matrix = np.block([
        [M_g_1_g_2, M_g_1_x2y2_g_2, M_g_1_z2_g_2],
        [M_g_1_x2y2_g_2, M_g_1_x2y2_2_g_2, M_g_1_x2y2z2_g_2],
        [M_g_1_z2_g_2, M_g_1_x2y2z2_g_2, M_g_1_z4_g_2]
    ])
    return M_matrix

# Create matrix v (equation C8)
def make_v(g_sets, V0_params):
    n_expansion = len(g_sets)
    v_g_1_H_g_2 = np.zeros((n_expansion, 1), dtype=np.complex128)
    v_g_1_x2y2_H_g_2 = np.zeros((n_expansion, 1), dtype=np.complex128)
    v_g_1_z2_H_g_2 = np.zeros((n_expansion, 1), dtype=np.complex128)

    for i in range(n_expansion):
        for k in range(n_expansion):
            v_g_1_H_g_2[i][0] += integrate_g_1_H_g_2(g_sets[i], g_sets[k], V0_params)
            v_g_1_x2y2_H_g_2[i][0] -= integrate_g_1_x2y2_H_g_2(g_sets[i], g_sets[k], V0_params)
            v_g_1_z2_H_g_2[i][0] -= integrate_g_1_z2_H_g_2(g_sets[i], g_sets[k], V0_params)

    v_matrix = np.block([
        [v_g_1_H_g_2],
        [v_g_1_x2y2_H_g_2],
        [v_g_1_z2_H_g_2]
    ])
    return v_matrix

# Update parameters via dq/dt = −j * M^−1 * v (equation 13)
# Note: The paper suggests updating only α and β using equation 13
#       while employing the Crank-Nicolson approach to update γ.
#       However, this code does not implement the Crank-Nicolson approach
#       and instead updates γ using equation 13 as well.
def update_q(g_sets, V0_params, dt=1e-3):
    n_expansion = len(g_sets)
    q = np.zeros((3 * n_expansion, 1), dtype=np.complex128)

    for i in range(n_expansion):
        q[i][0] = g_sets[i].γ
        q[n_expansion + i][0] = g_sets[i].α
        q[2 * n_expansion + i][0] = g_sets[i].β

    M_inv = np.linalg.inv(make_M(g_sets))
    v = make_v(g_sets, V0_params)
    dq_dt = -1.j * np.matmul(M_inv, v)
    q += dq_dt * dt

    for i in range(n_expansion):
        g_sets[i].γ = q[i][0]
        g_sets[i].α = q[n_expansion + i][0]
        g_sets[i].β = q[2 * n_expansion + i][0]

# Normalize wavefunction to ensure the total probability is 1
def normalize(g_sets):
    norm = 0
    n_expansion = len(g_sets)
    
    for i in range(n_expansion):
        for k in range(n_expansion):
            norm += integrate_g_1_g_2(g_sets[i], g_sets[k])

    delta_γ = - np.log(norm.real) / 2
    for g in g_sets:
        g.γ += delta_γ

# Calculate the energy of the system
def eval_energy(g_sets, V0_params):
    energy = 0
    norm = 0
    n_expansion = len(g_sets)

    for i in range(n_expansion):
        for k in range(n_expansion):
            energy += integrate_g_1_H_g_2(g_sets[i], g_sets[k], V0_params)
            norm += integrate_g_1_g_2(g_sets[i], g_sets[k])

    return energy / norm

# Plot the wavefunction
def plot_wavefunction(g_sets):
    z = np.linspace(0, 10, 100)
    psi_real = eval_psi(g_sets, x=0, y=0, z=z).real
    psi_imag = eval_psi(g_sets, x=0, y=0, z=z).imag
    plt.plot(z, psi_real, label='Real part')
    plt.plot(z, psi_imag, label='Imaginary part')
    plt.xlabel('z')
    plt.ylabel('ψ(z)')
    plt.title('Wavefunction along z-axis')
    plt.legend()
    plt.grid(True)
    plt.show()

def main():
    # Change to your path
    os.chdir('E:\\XUTTAI\\Desktop\\tdvp')

    # Load data
    groundstate_expansion_params = np.load('groundstate_expansion_params.npz')
    #groundstate_expansion_params = np.load('groundstate_expansion_params_tf.npz')
    values_γ = groundstate_expansion_params['values_γ']
    values_σ = groundstate_expansion_params['values_σ']

    V0_expansion_params = np.load('V0_expansion_params.npz')
    #V0_expansion_params = np.load('V0_expansion_params_tf.npz')
    values_C = V0_expansion_params['values_C']
    values_A = V0_expansion_params['values_σ']

    print('Groundstate bases number:', len(values_γ)) # 6 bases
    print('Soft Coulomb potential bases number:', len(values_C)) # 5 bases

    g_sets = []
    V0_params = np.zeros((len(values_C), 2), dtype=np.complex128)

    for i in range(len(values_γ)):
        g_i = g_basis(n=0, γ=values_γ[i], α=values_σ[i], β=values_σ[i])
        g_sets.append(g_i)

    for i in range(len(values_C)):
        V0_params[i, 0] = values_C[i]
        V0_params[i, 1] = values_A[i]

    print('Initial Energy:', eval_energy(g_sets, V0_params))
    # Time evolution loop
    t_max = 100.0
    dt = 0.001
    t = 0
    t_list = []
    psi_real_test = []
    psi_imag_test = []

    for _ in range(int(t_max / dt)):
        #plot_wavefunction(g_sets)
        t += dt
        t_list.append(t)
        normalize(g_sets)
        update_q(g_sets, V0_params, dt)
        print('Energy:', eval_energy(g_sets, V0_params))
        psi_real_test.append(eval_psi(g_sets, x=0, y=0, z=1).real)
        psi_imag_test.append(eval_psi(g_sets, x=0, y=0, z=1).imag)

    plt.plot(t_list, psi_real_test, label='Real part at z=1')
    plt.plot(t_list, psi_imag_test, label='Imaginary part at z=1')
    plt.xlabel('t')
    plt.ylabel('Wavefunction')
    plt.title(f'Wavefunction Evolution at z=1 with {len(values_γ)} bases')
    plt.legend()
    plt.grid(True)
    plt.savefig('wavefunction_evolution.png', dpi=300, bbox_inches='tight')
    plt.show()

if __name__ == '__main__':
    main()

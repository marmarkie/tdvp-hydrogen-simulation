"""    
    Note: Based on tdvp.py, this code adds Crank-Nicolson approach to update the coefﬁcients γ.
          However, the energy grows significantly when simulating groundstate.
          The author is still trying to fix the problem.            
    This code implements the PTG-basis to simulate a hydrogen atom under a soft Coulomb potential.
    The simulation starts from the ground state, with parameters loaded from 'groundstate_expansion_params.npz', 
    which is generated by 'gaussian_expansion_for_groundstate.py' and contains 5 PTG bases (all with n = 0).
    The parameters of the soft Coulomb potential are loaded from 'V0_expansion_params.npz', 
    which is generated by 'gaussian_expansion_for_potential.py' and contains 5 Gaussian bases.
    The initial energy is -0.27490287, which is close to -0.27489135 as reported in the paper.
"""

import numpy as np
import matplotlib.pyplot as plt
import os
import sys
import copy
from gaussian_integration import * 

# Evaluate wavefunction at (x, y, z)
def eval_psi(g_sets, x=0, y=0, z=0):
    psi = 0 + 0j
    for g in g_sets:
        psi += z ** g.n * np.exp(g.γ - g.α * (x**2 + y**2) - g.β * z**2)
    return psi

# Create matrix M (equation C7)
def make_M(g_sets):
    n_expansion = len(g_sets)
    M_g_1_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    M_g_1_x2y2_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    M_g_1_z2_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    M_g_1_x2y2_2_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    M_g_1_x2y2z2_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    M_g_1_z4_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)

    for i in range(n_expansion):
        for j in range(n_expansion):
            M_g_1_g_2[i][j] = integrate_g_1_g_2(g_sets[i], g_sets[j])
            M_g_1_x2y2_g_2[i][j] = -integrate_g_1_x2y2_g_2(g_sets[i], g_sets[j])
            M_g_1_z2_g_2[i][j] = -integrate_g_1_z2_g_2(g_sets[i], g_sets[j])
            M_g_1_x2y2_2_g_2[i][j] = integrate_g_1_x2y2_2_g_2(g_sets[i], g_sets[j])
            M_g_1_x2y2z2_g_2[i][j] = integrate_g_1_x2y2z2_g_2(g_sets[i], g_sets[j])
            M_g_1_z4_g_2[i][j] = integrate_g_1_z4_g_2(g_sets[i], g_sets[j])

    M_matrix = np.block([
        [M_g_1_g_2, M_g_1_x2y2_g_2, M_g_1_z2_g_2],
        [M_g_1_x2y2_g_2, M_g_1_x2y2_2_g_2, M_g_1_x2y2z2_g_2],
        [M_g_1_z2_g_2, M_g_1_x2y2z2_g_2, M_g_1_z4_g_2]
    ])
    return M_matrix

# Create matrix v (equation C8)
def make_v(g_sets, V0_params):
    n_expansion = len(g_sets)
    v_g_1_H_g_2 = np.zeros((n_expansion, 1), dtype=np.complex128)
    v_g_1_x2y2_H_g_2 = np.zeros((n_expansion, 1), dtype=np.complex128)
    v_g_1_z2_H_g_2 = np.zeros((n_expansion, 1), dtype=np.complex128)

    for i in range(n_expansion):
        for k in range(n_expansion):
            v_g_1_H_g_2[i][0] += integrate_g_1_H_g_2(g_sets[i], g_sets[k], V0_params)
            v_g_1_x2y2_H_g_2[i][0] -= integrate_g_1_x2y2_H_g_2(g_sets[i], g_sets[k], V0_params)
            v_g_1_z2_H_g_2[i][0] -= integrate_g_1_z2_H_g_2(g_sets[i], g_sets[k], V0_params)

    v_matrix = np.block([
        [v_g_1_H_g_2],
        [v_g_1_x2y2_H_g_2],
        [v_g_1_z2_H_g_2]
    ])
    return v_matrix

# Create matrix S (equation 26)
def make_S(g_sets_1, g_sets_2):
    n_expansion = len(g_sets_1)
    # S(t, t) matrix
    S_t_t = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    # S(t, t + dt) matrix
    S_t_dt = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    # S(t + dt, t + dt) matrix
    S_dt_dt = np.zeros((n_expansion, n_expansion), dtype=np.complex128)

    for i in range(n_expansion):
        for j in range(n_expansion):
            S_t_t[i][j] = integrate_g_1_g_2(g_sets_1[i], g_sets_1[j])
            S_t_dt[i][j] = integrate_g_1_g_2(g_sets_1[i], g_sets_2[j])
            S_dt_dt[i][j] = integrate_g_1_g_2(g_sets_2[i], g_sets_2[j])
    
    return S_t_t, S_t_dt, S_dt_dt

# equation 27, 29
def update_c(g_sets_1, g_sets_2, V0_params, dt):
    n_expansion = len(g_sets_1)
    S_t_t, S_t_dt, S_dt_dt = make_S(g_sets_1, g_sets_2)
    c_t_t = np.zeros((n_expansion, 1), dtype=np.complex128)
    for i in range(n_expansion):
        c_t_t[i, 0] = np.exp(g_sets_1[i].γ)
    S_t_dt_inv = np.linalg.inv(S_t_dt)
    S_t_t_inv = np.linalg.inv(S_t_t)

    # c(t, t + dt) = S(t, t + dt)^-1 @ S(t, t) @ c(t, t)
    # It seems there is a typo in equation 27 in the paper,
    # which says c(t, t + dt) = S(t, t)^-1 @ S(t, t + dt) @ c(t, t)
    c_t_dt = S_t_dt_inv @ S_t_t @ c_t_t 
    #c_t_dt = S_t_t_inv @ S_t_dt @ c_t_t 

    for i in range(n_expansion):
        g_sets_2[i].γ = np.log(c_t_dt[i, 0])

    #H_t_t_matrix = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    H_dt_dt_matrix = np.zeros((n_expansion, n_expansion), dtype=np.complex128)

    for i in range(n_expansion):
        for j in range(n_expansion):
            H_dt_dt_matrix[i][j] = integrate_g_1_H_g_2(g_sets_2[i], g_sets_2[j], V0_params)

    c_dt_dt = np.linalg.inv(S_dt_dt + 1j / 2 * H_dt_dt_matrix * dt) @ (S_dt_dt - 1j / 2 * H_dt_dt_matrix * dt) @ c_t_dt
    #c_dt_dt = np.linalg.inv(S_dt_dt - 1j * H_dt_dt_matrix * dt) @ c_t_dt

    for i in range(n_expansion):
        g_sets_2[i].γ = np.log(c_dt_dt[i, 0])
    #g_sets_1 = np.copy(g_sets_2)
    #print('g_sets_1',g_sets_1[0].γ, g_sets_1[0].α, g_sets_1[0].β)
    #print('g_sets_2',g_sets_2[0].γ, g_sets_2[0].α, g_sets_2[0].β)
    '''
    psi_real = eval_psi(g_sets_1, x=0, y=0, z=z).real
    psi_2_real = eval_psi(g_sets_2, x=0, y=0, z=z).real
    psi_imag = eval_psi(g_sets_1, x=0, y=0, z=z).imag
    psi_2_imag = eval_psi(g_sets_2, x=0, y=0, z=z).imag    
    
    plt.plot(z,psi_real)
    plt.plot(z,psi_2_real)
    plt.plot(z,psi_imag)
    plt.plot(z,psi_2_imag)   
    plt.show()  '''
    return g_sets_2
    
# Update parameters via dq/dt = −j * M^−1 * v (equation 13)
# Note: Update only α and β using equation 13
#       while employing the Crank-Nicolson approach to update γ.
def update_q(g_sets, V0_params, dt=1e-3):
    n_expansion = len(g_sets)
    g_sets_2 = copy.deepcopy(g_sets)
    q = np.zeros((3 * n_expansion, 1), dtype=np.complex128)
    for i in range(n_expansion):
        q[i][0] = g_sets[i].γ
        q[n_expansion + i][0] = g_sets[i].α
        q[2*n_expansion + i][0] = g_sets[i].β
    M_inv = np.linalg.inv(make_M(g_sets))  
    v = make_v(g_sets, V0_params)          
    dq_dt = -1.j * np.matmul(M_inv, v)    
    for i in range(n_expansion):
        dq_dt[i][0] = np.complex128(0)
    q += dq_dt * dt    
    for i in range(n_expansion):
        #g_sets[i].γ = q[i][0]
        g_sets_2[i].α = q[n_expansion + i][0]
        g_sets_2[i].β = q[2*n_expansion + i][0]
    g_sets = update_c(g_sets, g_sets_2, V0_params, dt)
    return g_sets

# Normalize wavefunction to ensure the total probability is 1
def normalize(g_sets):
    norm = 0
    n_expansion = len(g_sets)
    
    for i in range(n_expansion):
        for k in range(n_expansion):
            norm += integrate_g_1_g_2(g_sets[i], g_sets[k])

    delta_γ = - np.log(norm.real) / 2
    for g in g_sets:
        g.γ += delta_γ

# Calculate the energy of the system
def eval_energy(g_sets, V0_params):
    energy = 0
    norm = 0
    n_expansion = len(g_sets)

    for i in range(n_expansion):
        for k in range(n_expansion):
            energy += integrate_g_1_H_g_2(g_sets[i], g_sets[k], V0_params)
            norm += integrate_g_1_g_2(g_sets[i], g_sets[k])

    return energy / norm

# Plot the wavefunction
def plot_wavefunction(g_sets):
    z = np.linspace(0, 10, 100)
    psi_real = eval_psi(g_sets, x=0, y=0, z=z).real
    psi_imag = eval_psi(g_sets, x=0, y=0, z=z).imag
    plt.plot(z, psi_real, label='Real part')
    plt.plot(z, psi_imag, label='Imaginary part')
    plt.xlabel('z')
    plt.ylabel('ψ(z)')
    plt.title('Wavefunction along z-axis')
    plt.legend()
    plt.grid(True)
    plt.show()

def main():
    # Change to your path
    os.chdir('E:\\XUTTAI\\Desktop\\tdvp\\other_versions\\Crank_Nicolson_approach_version')

    # Load data
    groundstate_expansion_params = np.load('groundstate_expansion_params.npz')
    values_γ = groundstate_expansion_params['values_γ']
    values_σ = groundstate_expansion_params['values_σ']

    V0_expansion_params = np.load('V0_expansion_params.npz')
    values_C = V0_expansion_params['values_C']
    values_A = V0_expansion_params['values_σ']

    g_sets = []
    V0_params = np.zeros((len(values_C), 2), dtype=np.complex128)

    for i in range(len(values_γ)):
        g_i = g_basis(n=0, γ=values_γ[i], α=values_σ[i], β=values_σ[i])
        g_sets.append(g_i)

    for i in range(len(values_C)):
        V0_params[i, 0] = values_C[i]
        V0_params[i, 1] = values_A[i]

    print('Initial Energy:', eval_energy(g_sets, V0_params))
    # Time evolution loop
    t_max = 5.0
    dt = 0.001
    t = 0
    t_list = []
    psi_real_test = []
    psi_imag_test = []

    for _ in range(int(t_max / dt)):
        t += dt
        t_list.append(t)
        #normalize(g_sets)
        g_sets = update_q(g_sets, V0_params, dt)
        #plot_wavefunction(g_sets)
        print('Energy:', eval_energy(g_sets, V0_params))
        psi_real_test.append(eval_psi(g_sets, x=0, y=0, z=1).real)
        psi_imag_test.append(eval_psi(g_sets, x=0, y=0, z=1).imag)

    plt.plot(t_list, psi_real_test, label='Real part at z=1')
    plt.plot(t_list, psi_imag_test, label='Imaginary part at z=1')
    plt.xlabel('t')
    plt.ylabel('Wavefunction')
    plt.title('Wavefunction Evolution at z=1')
    plt.legend()
    plt.grid(True)
    plt.savefig('wavefunction_evolution.png', dpi=300, bbox_inches='tight')
    plt.show()

if __name__ == '__main__':
    main()

"""
    Note: This code utilizes SymPy to parse the kernel function and operator, 
          and to calculate Gaussian integrations through recursion. 
          However, the use of SymPy introduces significant computational overhead, 
          making this implementation much slower. 
          As a result, this serves as a slow but concise version of tdvp.py, 
          useful for verifying integration results in gaussian_integration.py.
          The paper suggests updating only α and β using dq/dt = −j * M^−1 * v (equation 13)
          while employing the Crank-Nicolson approach to update γ.
          However, this code does not implement the Crank-Nicolson approach
          and instead updates γ using equation 13 as well. 
    This code implements the PTG-basis to simulate a hydrogen atom under a soft Coulomb potential.
    The simulation starts from the ground state, with parameters loaded from 'groundstate_expansion_params.npz', 
    which is generated by 'gaussian_expansion_for_groundstate.py' and contains 3 PTG bases (all with n = 0).
    The parameters of the soft Coulomb potential are loaded from 'V0_expansion_params.npz', 
    which is generated by 'gaussian_expansion_for_potential.py' and contains 5 Gaussian bases.
    The initial energy is -0.27490287, which is close to -0.27489135 as reported in the paper.
"""
import numpy as np
import matplotlib.pyplot as plt
import os
import time
import sympy as sp

# Global timing variables
total_time_spent_in_parse_expression = 0
total_time_spent_in_update_q = 0

# Double factorial function for calculating integrals
def double_factorial(n):
    result = 1
    for i in range(n, 0, -2):
        result *= i
    return result

# B10 without γ
# g_σ(z) = e^(-σ * z^2)
# <g_σ1|z^k * e^(-ν*z^2)|g_σ2>
def integrate_g_σ1_zk_g_σ2(σ1, k, ν, σ2):
    if k % 2 == 1:
        return np.complex128(0)
    σ1 = np.complex128(σ1)
    σ2 = np.complex128(σ2)
    ν = np.complex128(ν)
    if (σ1.conjugate() + σ2 + ν) <= 0:
        print('Zero warning: Result may be invalid due to negative exponent.')
        return np.complex128(1)
    else:
        result = double_factorial(k - 1) * np.sqrt(np.pi)
        term1 = np.power(σ1.conjugate() + σ2 + ν, -(k + 1) / 2)
        term2 = np.power(2, -k / 2)
        return np.complex128(result * term1 * term2)

# g = z^n * e^(γ−α(x^2+y^2)−βz^2)
class g_basis:
    def __init__(self, n, γ, α, β, direction='z'):
        self.n = n
        self.γ = γ
        self.α = α
        self.β = β

# Parse a kernel expression to obtain coefficients and degrees
def parse_expression(kernel_str, operater=None):
    if kernel_str == '1':
        return 1, [1], [[0, 0, 0]]
    x, y, z = sp.symbols('x y z')
    expr = sp.sympify(kernel_str)
    expanded_expr = sp.expand(expr)
    terms_dict = expanded_expr.as_coefficients_dict()
    cof = []
    degree = []    
    for term, coeff in terms_dict.items():
        cof.append(float(coeff.evalf()))
        term_degrees = [term.as_coeff_exponent(x)[1], term.as_coeff_exponent(y)[1], term.as_coeff_exponent(z)[1]]
        degree.append(term_degrees)
    return len(cof), np.array(cof), np.array(degree)

# Perform kernel integration
def kernel_integration(kernel_str, g_1, g_2, operater=None, V0_params=None, ν=0):
    global total_time_spent_in_parse_expression
    start_time_parse = time.time()
    
    terms, cof, degree = parse_expression(kernel_str, operater)
    
    total_time_spent_in_parse_expression += time.time() - start_time_parse
   
    integration_result = 0
    if operater == 'H':
        kinetic_integration_result = 2 * g_2.α * kernel_integration('1' + '*' + kernel_str, g_1, g_2) - 2 * g_2.α ** 2 * kernel_integration('(x**2 + y**2)' + '*' + kernel_str, g_1, g_2)
        if g_2.n >= 2:
            kinetic_integration_result += -g_2.n * (g_2.n - 1) * kernel_integration('z**(-2)' + '*' + kernel_str, g_1, g_2) / 2
        kinetic_integration_result += (2 * g_2.n + 1) * g_2.β * kernel_integration('1' + '*' + kernel_str, g_1, g_2) - 2 * g_2.β ** 2 * kernel_integration('z**2' + '*' + kernel_str, g_1, g_2)
        
        potential_integration_result = sum(V0_params[i, 0] * kernel_integration('1' + '*' + kernel_str, g_1, g_2, ν=V0_params[i, 1]) for i in range(V0_params.shape[0]))

        return kinetic_integration_result + potential_integration_result

    else:
        for i in range(terms):
            x_integration = integrate_g_σ1_zk_g_σ2(σ1=g_1.α, k=degree[i][0], ν=ν, σ2=g_2.α)
            y_integration = integrate_g_σ1_zk_g_σ2(σ1=g_1.α, k=degree[i][1], ν=ν, σ2=g_2.α)
            z_integration = integrate_g_σ1_zk_g_σ2(σ1=g_1.β, k=g_1.n + g_2.n + degree[i][2], ν=ν, σ2=g_2.β)
            integration_result += cof[i] * x_integration * y_integration * z_integration
        integration_result *= np.exp(g_1.γ.conjugate() + g_2.γ)
    return integration_result

# Construct the M matrix
def make_M(g_sets):
    n_expansion = len(g_sets)
    M_g_1_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    M_g_1_x2y2_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    M_g_1_z2_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    M_g_1_x2y2_2_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    M_g_1_x2y2z2_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)
    M_g_1_z4_g_2 = np.zeros((n_expansion, n_expansion), dtype=np.complex128)

    for i in range(n_expansion):
        for j in range(n_expansion):
            M_g_1_g_2[i][j] = kernel_integration('1', g_sets[i], g_sets[j])
            M_g_1_x2y2_g_2[i][j] = -kernel_integration('(x**2 + y**2)', g_sets[i], g_sets[j])
            M_g_1_z2_g_2[i][j] = -kernel_integration('(z**2)', g_sets[i], g_sets[j])
            M_g_1_x2y2_2_g_2[i][j] = kernel_integration('(x**2 + y**2) ** 2', g_sets[i], g_sets[j])
            M_g_1_x2y2z2_g_2[i][j] = kernel_integration('(x**2 + y**2) * z**2', g_sets[i], g_sets[j])
            M_g_1_z4_g_2[i][j] = kernel_integration('z**4', g_sets[i], g_sets[j])

    M_matrix = np.block([
        [M_g_1_g_2, M_g_1_x2y2_g_2, M_g_1_z2_g_2],
        [M_g_1_x2y2_g_2, M_g_1_x2y2_2_g_2, M_g_1_x2y2z2_g_2],
        [M_g_1_z2_g_2, M_g_1_x2y2z2_g_2, M_g_1_z4_g_2]
    ])
    return M_matrix

# Construct the v matrix
def make_v(g_sets, V0_params):
    n_expansion = len(g_sets)
    v_g_1_H_g_2 = np.zeros((n_expansion, 1), dtype=np.complex128)
    v_g_1_x2y2_H_g_2 = np.zeros((n_expansion, 1), dtype=np.complex128)
    v_g_1_z2_H_g_2 = np.zeros((n_expansion, 1), dtype=np.complex128)

    for i in range(n_expansion):
        for k in range(n_expansion):
            v_g_1_H_g_2[i][0] += kernel_integration('1', g_sets[i], g_sets[k], operater='H', V0_params=V0_params)
            v_g_1_x2y2_H_g_2[i][0] -= kernel_integration('(x**2 + y**2)', g_sets[i], g_sets[k], operater='H', V0_params=V0_params)
            v_g_1_z2_H_g_2[i][0] -= kernel_integration('(z**2)', g_sets[i], g_sets[k], operater='H', V0_params=V0_params)

    v_matrix = np.block([
        [v_g_1_H_g_2],
        [v_g_1_x2y2_H_g_2],
        [v_g_1_z2_H_g_2]
    ])
    return v_matrix

# Update the q parameters via dq/dt = −j * M^−1 * v
def update_q(g_sets, V0_params, dt=1e-3j):
    n_expansion = len(g_sets)
    q = np.zeros((3 * n_expansion, 1), dtype=np.complex128)

    for i in range(n_expansion):
        q[i][0] = g_sets[i].γ
        q[n_expansion + i][0] = g_sets[i].α
        q[2 * n_expansion + i][0] = g_sets[i].β

    global total_time_spent_in_update_q
    t1 = time.time()
    M_inv = np.linalg.inv(make_M(g_sets))
    t2 = time.time()
    total_time_spent_in_update_q += t2 - t1

    v = make_v(g_sets, V0_params)
    dq_dt = -1.j * np.matmul(M_inv, v)
    q += dq_dt * dt

    for i in range(n_expansion):
        g_sets[i].γ = q[i][0]
        g_sets[i].α = q[n_expansion + i][0]
        g_sets[i].β = q[2 * n_expansion + i][0]

# Normalize the wavefunction to ensure the total probability is 1
def normalize(g_sets):
    norm = 0
    n_expansion = len(g_sets)

    for i in range(n_expansion):
        for k in range(n_expansion):
            norm += kernel_integration('1', g_sets[i], g_sets[k])

    delta_γ = -np.log(norm.real) / 2

    for g in g_sets:
        g.γ += delta_γ

# Evaluate the energy of the system
def eval_energy(g_sets, V0_params):
    normalize(g_sets)
    energy = 0
    norm = 0
    n_expansion = len(g_sets)

    for i in range(n_expansion):
        for k in range(n_expansion):
            energy += kernel_integration('1', g_sets[i], g_sets[k], operater='H', V0_params=V0_params)
            norm += kernel_integration('1', g_sets[i], g_sets[k])

    return energy / norm

# Evaluate the wavefunction at given (x, y, z)
def eval_psi(g_sets, x=0, y=0, z=0):
    psi = 0 + 0j
    for g in g_sets:
        psi += z ** g.n * np.exp(g.γ - g.α * (x**2 + y**2) - g.β * z**2)
    return psi

# Main simulation loop
def main():
    # Change to your path
    os.chdir('E:\\XUTTAI\\Desktop\\tdvp\\other_versions\\sympy_version')

    # Load ground state and potential parameters
    groundstate_expansion_params = np.load('groundstate_expansion_params.npz')
    values_γ = groundstate_expansion_params['values_γ']
    values_σ = groundstate_expansion_params['values_σ']

    V0_expansion_params = np.load('V0_expansion_params.npz')
    values_C = V0_expansion_params['values_C']
    values_A = V0_expansion_params['values_σ']

    g_sets = []
    V0_params = np.zeros((len(values_C), 2), dtype=np.complex128)

    for i in range(len(values_γ)):
        g_i = g_basis(n=0, γ=values_γ[i], α=values_σ[i], β=values_σ[i])
        g_sets.append(g_i)

    for i in range(len(values_C)):
        V0_params[i, 0] = values_C[i]
        V0_params[i, 1] = values_A[i]

    print("Initial Energy:", eval_energy(g_sets, V0_params))

    t_max = 1.0
    dt = 0.01
    t = 0
    t_list = []
    psi_real_test = []
    psi_imag_test = []

    start_time_total = time.time()

    for _ in range(int(t_max / dt)):
        t += dt
        t_list.append(t)
        normalize(g_sets)
        update_q(g_sets, V0_params, dt)
        #plot_wavefunction(g_sets)
        print('Energy:', eval_energy(g_sets, V0_params))
        psi_real_test.append(eval_psi(g_sets, x=0, y=0, z=1).real)
        psi_imag_test.append(eval_psi(g_sets, x=0, y=0, z=1).imag)

    end_time_total = time.time()

    # Plot the results
    plt.plot(t_list, psi_real_test, label='Real part at z=1')
    plt.plot(t_list, psi_imag_test, label='Imaginary part at z=1')
    plt.xlabel('t')
    plt.ylabel('Wavefunction')
    plt.title('Wavefunction Evolution at z=1')
    plt.legend()
    plt.grid(True)
    plt.savefig('wavefunction_evolution.png', dpi=300, bbox_inches='tight')
    plt.show()

    print("Total time:", end_time_total - start_time_total)
    print("Total time spent in parse_expression:", total_time_spent_in_parse_expression)
    print("Total time spent in update_q:", total_time_spent_in_update_q)

if __name__ == '__main__':
    main()
